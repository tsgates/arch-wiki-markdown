Creating Packages
=================

Summary

This article covers technical knowledge, required to create packages for
submission in AUR. For instructions regarding existing rules and ways to
improve package quality see Arch Packaging Standards.

Related

Arch Build System

Arch User Repository

makepkg

pacman

PKGBUILD

Patching in ABS

This article aims to assist users creating their own packages using the
Arch Linux "ports-like" build system. It covers creation of a PKGBUILD –
a package build description file sourced by makepkg to create a binary
package from source. If already in possession of a PKGBUILD, see
makepkg.

+--------------------------------------------------------------------------+
| Contents                                                                 |
| --------                                                                 |
|                                                                          |
| -   1 Overview                                                           |
| -   2 Preparation                                                        |
|     -   2.1 Prerequisite software                                        |
|     -   2.2 Download and test the installation                           |
|                                                                          |
| -   3 Creating a PKGBUILD                                                |
|     -   3.1 Defining PKGBUILD variables                                  |
|     -   3.2 PKGBUILD Functions                                           |
|         -   3.2.1 The pkgver() function                                  |
|         -   3.2.2 The prepare() function                                 |
|         -   3.2.3 The build() function                                   |
|         -   3.2.4 The check() function                                   |
|         -   3.2.5 The package() function                                 |
|                                                                          |
| -   4 Testing the PKGBUILD and package                                   |
|     -   4.1 Checking package sanity                                      |
|                                                                          |
| -   5 Submitting packages to the AUR                                     |
| -   6 Summary                                                            |
|     -   6.1 Warnings                                                     |
|                                                                          |
| -   7 More detailed guidelines                                           |
| -   8 See Also                                                           |
+--------------------------------------------------------------------------+

Overview
--------

Packages in Arch Linux are built using the makepkg utility and the
information stored in a PKGBUILD file. When makepkg is run, it searches
for a PKGBUILD in the current directory and follows the instructions
therein to either compile or otherwise acquire the required files to be
packaged within a package file (pkgname.pkg.tar.xz). The resulting
package contains binary files and installation instructions; readily
installed with pacman.

An Arch package is no more than a tar archive, or 'tarball', compressed
using xz, which contains the following files generated by makepkg:

-   The binary files to install.
-   .PKGINFO: contains all the metadata needed by pacman to deal with
    packages, dependencies, etc.
-   .INSTALL: an optional file used to execute commands after the
    install/upgrade/remove stage. (This file is present only if
    specified in the PKGBUILD.)
-   .Changelog: an optional file kept by the package maintainer
    documenting the changes of the package. (It is not present in all
    packages.)

Preparation
-----------

> Prerequisite software

First ensure that the necessary tools are installed. The package group
base-devel should be sufficient; it includes make and additional tools
needed for compiling from source.

    # pacman -S base-devel

One of the key tools for building packages is makepkg (provided by
pacman) which does the following:

1.  Checks if package dependencies are installed.
2.  Downloads the source file(s) from the specified server(s).
3.  Unpacks the source file(s).
4.  Compiles the software and installs it under a fakeroot environment.
5.  Strips symbols from binaries and libraries.
6.  Generates the package meta file which is included with each package.
7.  Compresses the fakeroot environment into a package file.
8.  Stores the package file in the configured destination directory,
    which is the present working directory by default.

> Download and test the installation

Download the source tarball of the software you want to package, extract
it, and follow the author's steps to install the program. Make a note of
all commands and/or steps needed to compile and install it. You will be
repeating those same commands in the PKGBUILD file.

Most software authors stick to the 3-step build cycle:

    ./configure
    make
    make install

This is a good time to make sure the program is working correctly.

Creating a PKGBUILD
-------------------

When you run makepkg, it will look for a PKGBUILD file in the present
working directory. If a PKGBUILD file is found it will download the
software's source code and compile it according to the instructions
specified in the PKGBUILD file. The instructions must be fully
interpretable by the Bash shell. After successful completion, the
resulting binaries and metadata of the package, i.e. package version and
dependencies, are packed in a pkgname.pkg.tar.xz package file that can
be installed with pacman -U <package file>.

To begin with a new package, you should first create an empty working
directory, (preferably ~/abs/pkgname), change into that directory, and
create a PKGBUILD file. You can either copy the prototype PKGBUILD
/usr/share/pacman/PKGBUILD.proto to your working directory or copy a
PKGBUILD from a similar package. The latter may be useful if you only
need to change a few options.

> Defining PKGBUILD variables

Example PKGBUILDs are located in /usr/share/pacman/. An explanation of
possible PKGBUILD variables can be found in the PKGBUILD article.

makepkg defines three variables that you should use as part of the build
and install process:

 startdir
    This contains the absolute path to the directory where the PKGBUILD
    file is located. This variable used to be used in combination with
    /src or /pkg postfixes, but the use of srcdir and pkgdir variables
    is the modern method. $startdir/src is not guaranteed to be the same
    as $srcdir, and likewise for $pkgdir. Use of this variable is
    deprecated and strongly discouraged.
 srcdir
    This points to the directory where makepkg extracts or copies all
    source files.
 pkgdir
    This points to the directory where makepkg bundles the installed
    package, which becomes the root directory of your built package.

Note:makepkg, and thus the build() and package() functions, are intended
to be non-interactive. Interactive utilities or scripts called in those
functions may break makepkg, particularly if it is invoked with
build-logging enabled (-l). (See FS#13214.)

Note:Apart from the current package Maintainer, there may be previous
maintainers listed above as Contributors.

> PKGBUILD Functions

There are 5 functions, listed here in the order they are executed if all
of them exist. If one does not exist, it is simply skipped.

Note:This does not apply to the package() function, as it is required in
every PKGBUILD

The pkgver() function

Beginning with pacman 4.1, you can update the pkgver variable during a
makepkg. pkgver() is run right after the sources are fetched and
extracted.

This is particularly useful if you are making git/svn/hg/etc. packages,
where the build process may remain the same, but the source could be
updated every day, even every hour. The old way of doing this was to put
the date into the pkgver field which, if the software was not updated,
makepkg would still rebuild it thinking the version had changed. Some
useful commands for this are git describe, hg identify -ni, etc. Please
test these before submitting a PKGBUILD, as a failure in the pkgver()
function can stop a build in it's tracks.

Note:pkgver cannot contain spaces or hyphens (-). Using sed to correct
this is common.

The prepare() function

Pacman 4.1 introduces the prepare() command. In this function commands
that are used to prepare sources for building are run, such as patch or
configuring. This function is run before the build function and after
the package extraction. If extraction is skipped (makepkg -e), then
prepare() is not run.

Note: (From man PKGBUILD) The function is run in bash -e mode, meaning
any command that exits with a non-zero status will cause the function to
exit.

The build() function

Now you need to implement the build() function in the PKGBUILD file.
This function uses common shell commands in Bash syntax to automatically
compile software and create a pkg directory to install the software to.
This allows makepkg to package files without having to sift through your
filesystem.

The first step in the build() function is to change into the directory
created by uncompressing the source tarball. In most common cases the
first command will look like this:

    cd "$srcdir/$pkgname-$pkgver"

Now, you need to list the same commands you used when you manually
compiled the software. The build() function in essence automates
everything you did by hand and compiles the software in the fakeroot
build environment. If the software you are packaging uses a configure
script, it is good practice to use --prefix=/usr when building packages
for pacman. A lot of software installs files relative to the /usr/local
directory, which should only be done if you are manually building from
source. All Arch Linux packages should use the /usr directory. As seen
in the /usr/share/pacman/PKGBUILD.proto file, the next two lines often
look like this:

    ./configure --prefix=/usr
    make

Note:If your software does not need to build anything, DO NOT use the
build() function. It is not required, but the package() function is.

The check() function

Place for calls to make check and similar testing routines. Users who
don't need it (and occasionally maintainers who can not fix a package
for this to pass) can disable it using !check in PKGBUILD/makepkg
options.

The package() function

The final step is to put the compiled files in a directory where makepkg
can retrieve them to create a package. This by default is the pkg
directory—a simple fakeroot environment. The pkg directory replicates
the hierarchy of the root file system of the software's installation
paths. If you have to manually place files under the root of your
filesystem, you should install them in the pkg directory under the same
directory structure. For example, if you want to install a file to
/usr/bin, it should instead be placed under $pkgdir/usr/bin. Very few
install procedures require the user to copy dozens of files manually.
Instead, for most software, calling make install will do so. The final
line should look like the following in order to correctly install the
software in the pkg directory:

    make DESTDIR="$pkgdir/" install

Note:It is sometimes the case where DESTDIR is not used in the Makefile;
you may need to use prefix instead. If the package is built with
autoconf/automake, use DESTDIR; this is what is documented in the
manuals. If DESTDIR does not work, try building with
make prefix="$pkgdir/usr/" install. If that does not work, you will have
to look further into the install commands that are executed by
"make <...> install".

In some odd cases, the software expects to be run from a single
directory. In such cases, it is wise to simply copy these to
$pkgdir/opt.

More often than not, the installation process of the software will
create any sub-directories below the pkg directory. If it does not,
however, makepkg will generate a lot of errors and you will need to
manually create sub-directories by adding the appropriate mkdir -p
commands in the build() function before the installation procedure is
run.

In old packages, there was no package() function. So, files were put
into the pkg directory at the end of the build() function. If package()
is not present, build() runs via fakeroot. In new packages, package() is
required and runs via fakeroot instead, and build() runs without any
special privileges.

makepkg --repackage runs only the package() function, so it creates a
*.pkg.* file without compiling the package. This may save time e.g. if
you just have changed the depends variable of the package.

Note:The package() function is the only required function in a PKGBUILD.
If you must only copy files into their respective directories to install
a program, do not put it in the build() function, put that in the
package() function.

Testing the PKGBUILD and package
--------------------------------

As you are writing the build() function, you will want to test your
changes frequently to ensure there are no bugs. You can do this using
the makepkg command in the directory containing the PKGBUILD file. With
a properly formatted PKGBUILD, makepkg will create a package; with a
broken or unfinished PKGBUILD, it will raise an error.

If makepkg finishes successfully, it will place a file named
pkgname-pkgver.pkg.tar.xz in your working directory. This package can be
installed with the pacman -U command. However, just because a package
file was built does not imply that it is fully functional. It might
conceivably contain only the directory and no files whatsoever if, for
example, a prefix was specified improperly. You can use pacman's query
functions to display a list of files contained in the package and the
dependencies it requires with pacman -Qlp [package file] and
pacman -Qip [package file] respectively.

If the package looks sane, then you are done! However, if you plan on
releasing the PKGBUILD file, it is imperative that you check and
double-check the contents of the depends array.

Also ensure that the package binaries actually run flawlessly! It is
annoying to release a package that contains all necessary files, but
crashes because of some obscure configuration option that does not quite
work well with the rest of the system. If you are only going to compile
packages for your own system, though, you do not need to worry too much
about this quality assurance step, as you are the only person suffering
from mistakes, after all.

> Checking package sanity

After testing package functionality check it for errors using namcap:

    $ namcap PKGBUILD
    $ namcap <package file name>.pkg.tar.xz

Namcap will:

1.  Check PKGBUILD contents for common errors and package file hierarchy
    for unnecessary/misplaced files
2.  Scan all ELF files in package using ldd, automatically reporting
    which packages with required shared libraries are missing from
    depends and which can be omitted as transitive dependencies
3.  Heuristically search for missing and redundant dependencies

and much more. Get into the habit of checking your packages with namcap
to avoid having to fix the simplest mistakes after package submission.

Submitting packages to the AUR
------------------------------

Please read AUR User Guidelines#Submitting packages for a detailed
description of the submission process.

Summary
-------

1.  Download the source tarball of the software you want to package.
2.  Try compiling the package and installing it into an arbitrary
    directory.
3.  Copy over the prototype /usr/share/pacman/PKGBUILD.proto and rename
    it to PKGBUILD in a temporary working directory -- preferably
    ~/abs/.
4.  Edit the PKGBUILD according to the needs of your package.
5.  Run makepkg and see whether the resulting package is built
    correctly.
6.  If not, repeat the last two steps.

> Warnings

-   Before you can automate the package building process, you should
    have done it manually at least once unless you know exactly what you
    are doing in advance, in which case you would not be reading this in
    the first place. Unfortunately, although a good bunch of program
    authors stick to the 3-step build cycle of "./configure; make;
    make install", this is not always the case, and things can get real
    ugly if you have to apply patches to make everything work at all.
    Rule of thumb: If you cannot get the program to compile from the
    source tarball, and make it install itself to a defined, temporary
    subdirectory, you do not even need to try packaging it. There is not
    any magic pixie dust in makepkg that makes source problems go away.
-   In a few cases, the packages are not even available as source and
    you have to use something like sh installer.run to get it to work.
    You will have to do quite a bit of research (read READMEs, INSTALL
    instructions, man pages, perhaps ebuilds from Gentoo or other
    package installers, possibly even the MAKEFILEs or source code) to
    get it working. In some really bad cases, you have to edit the
    source files to get it to work at all. However, makepkg needs to be
    completely autonomous, with no user input. Therefore if you need to
    edit the makefiles, you may have to bundle a custom patch with the
    PKGBUILD and install it from inside the build() function, or you
    might have to issue some sed commands from inside the build()
    function.

More detailed guidelines
------------------------

Package creation guidelines

* * * * *

CLR – Cross – Eclipse – Free Pascal – GNOME – Go – Haskell – Java – KDE
– Kernel – Lisp – MinGW – Nonfree – OCaml – Perl – Python – Ruby – VCS –
Web – Wine

See Also
--------

-   How to correctly create a patch file.

Retrieved from
"https://wiki.archlinux.org/index.php?title=Creating_Packages&oldid=254464"

Categories:

-   About Arch
-   Package development
